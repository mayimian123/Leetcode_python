# 二叉树的修改与构造

本文总结了LeetCode上关于二叉树修改和构造的几道经典题目，包括验证二叉搜索树、合并二叉树以及最大二叉树的构造。

## 1. 验证二叉搜索树（LeetCode 98）

### 题目描述
给定一个二叉树的根节点，判断其是否是一个有效的二叉搜索树（BST）。

### 解题思路
- 利用BST的中序遍历是递增序列的特性
- 通过中序遍历将节点值存入数组
- 检查数组是否严格递增

### 代码实现
```python
def isValidBST(self, root):
    self.vec = []
    self.traversal(root)
    for i in range(1, len(self.vec)):
        if self.vec[i] <= self.vec[i-1]:
            return False
    return True

def traversal(self, root):
    if root is None:
        return 
    self.traversal(root.left)
    self.vec.append(root.val)
    self.traversal(root.right)
```

## 2. 合并二叉树（LeetCode 617）

### 题目描述
给定两个二叉树，将它们合并为一个新的二叉树。合并规则是：如果两个节点重叠，将它们的值相加作为节点合并后的新值。

### 解题思路
- 采用递归方法
- 同时遍历两棵树的对应节点
- 如果一个节点为空，返回另一个节点
- 节点值相加，递归处理左右子树

### 代码实现
```python
def mergeTrees(self, root1, root2):
    if root1 is None:
        return root2
    if root2 is None:
        return root1
    root1.val += root2.val
    root1.left = self.mergeTrees(root1.left, root2.left)
    root1.right = self.mergeTrees(root1.right, root2.right)
    return root1
```

## 3. 最大二叉树（LeetCode 654）

### 题目描述
给定一个不含重复元素的整数数组，构造一个最大二叉树。构造规则：
- 根节点是数组中的最大值
- 左子树是最大值左边部分递归构造的最大二叉树
- 右子树是最大值右边部分递归构造的最大二叉树

### 解题思路
- 找到数组中的最大值及其索引
- 将数组分成左右两部分
- 递归构造左右子树
- 基本情况：数组长度为1时直接返回节点

### 代码实现
```python
def constructMaximumBinaryTree(self, nums):
    if len(nums) == 1:
        return TreeNode(nums[0])
    node = TreeNode(0)
    max_value = 0
    max_value_index = 0
    # 找最大值及其索引
    for i in range(len(nums)):
        if nums[i] > max_value:
            max_value = nums[i]
            max_value_index = i
    node.val = max_value
    # 构造左子树
    if max_value_index > 0:
        node.left = self.constructMaximumBinaryTree(nums[:max_value_index])
    # 构造右子树
    if max_value_index < len(nums)-1:
        node.right = self.constructMaximumBinaryTree(nums[max_value_index+1:])
    return node
```

## 总结

这些题目展示了二叉树操作的不同方面：
1. 验证二叉搜索树：利用BST的特性进行验证
2. 合并二叉树：两个树的节点操作和递归思想
3. 最大二叉树：根据特定规则构造二叉树的递归实现

关键技巧：
- 善用递归
- 理解二叉树的特性（如BST的中序遍历特性）
- 分治思想在树操作中的应用
- 边界条件的处理（如空节点的处理）
