## 回溯算法
模版：
    【输出】递归函数都没有返回值
    【输入】参数 backtracking
    【终止条件】收集结果的过程 通常在叶子节点的时候收集节点 return 
    【搜索逻辑】for 参数用来处理集合里面的每一个元素 处理节点 递归 撤销处理节点的过程

## 组合
### 77.组合
1. 输出：result存放结果
2. 输入：n k startindex输入的标识 每一次输入的标识都需要+1 path result
3. 终止条件 if len(path)==k 将path[:]存入result中
4. 搜索逻辑：
    for startindex,n+1——————剪枝逻辑：n-（k-len（path））+2 
        path.append startindex
        backtracking 这里的i+1
        path.pop 回溯


### 17.电话号码的字母组合
- 回溯：根据输入的字符串 输出所有可能的组合
1. 输入：字符串str 索引index表示s呈现的数字个数
2. 输出：字符串s来收集叶子节点的结果 result来收集所有的结果
3. 终止条件：
    到达叶子节点 也就是index==len（s）回收结果 result.append
4. 回溯逻辑：
    找到index指的数字 对应map里面
    利用for循环来处理字符集

### 39.组合总和
- 回溯：candidates 是无重复元素的数组 target是目标数 要求 找到candidates中可以使得数据和为target的组合 可以重复选取
1. 输入：
    已知内容：candidates target 
    全局变量：path result
    过程变量：cursum用于存放当前的总和 startIndex起始位置
2. 输出：result
3. 终止条件：
    如果cursum>target return
    如果cursum==target append
4. 递归逻辑：
    for i in range(startIndex,len(candidates)):
        path append
        cursum+
        回溯 此时不需要+1 因为可以重复取数字
        cursum-
        path pop

### 40.组合总和Ⅱ
- 回溯：需要进行树层的去重 给定数组candidates 和target 需要找到所有和为target的组合 数字只能使用一次 不能重复
- 思路：在39的基础上 
- 实现树层去重：先对树进行sort 如果当前的candidates[i]==[i-1]那么continue 如果是总和大于target 那么就break
- 不能重复使用元素 循环i+1



### 216.组合总和Ⅲ
- 回溯：找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
    1. 输出：result path
    2. 输入：targetsum目标总和 cursum当前总和 k目标数量 path当前数量 result结果
    3. 终止条件：
        如果cursum>targetsum return剪枝操作
        如果cursum==targetsum and len(path)==result
            将结果append 返回
    4. 回溯逻辑：
        for startindex 9-(k-len(nums))+2 剪枝操作
            cursum+=startindex
            path append
            回溯 此时i+1
            path pop
            cursum-=startindex

## 分割
### 131.分割回文串
- 回溯： 给一个字符串 将s变为子串 使得每一个子串都是回文串
1. 输入:
    已知条件：字符串s
    全局变量：path result
    过程变量：startindex
2. 输出：result
3. 终止条件：
    如果此时的startinde>len(s) result.append return
4. 递归逻辑：
    ispalindrome判断是否是回文串：s [startindex,i] 
        利用双指针 从前往后和从后往前来判断 return true/false
    如果是的话：
        path.append(s[])
        递归
        pop

### 93.复原IP地址
- 回溯：给定一个只包含数字的字符串 复原并返回所有可能的IP地址
- 要求：有3个点，不能有无效字符，每一个数的范围为[0,255]，不能有前导0
1. 输入：
    已知条件 string
    结果变量：result path
    过程变量：startindex 代表起始位置 pointNum代表添加逗点数量
2. 输出 result
3. 终止条件：
    当逗点为3且剩下合法
        current+=s[start_index:]
        result.append(current)
4. 单层搜索的逻辑：
    需要判断[startindex,1]是否合法
    如果合法：
        sub=s[start_index:i+1] 
        self.i+1 pointnum+1 current+sub+'.'
5. 如何看是否valid：
    start>end false
    s[start]=='0' and start!=end false
    nume=0
    for i in range(start,end+1):
        if not s[i].isdigit():
            return false
        num=num*10+int(s[i])
        if num>255:
            return false
    return true
如果pointNum为3的话就结束

## 子集
### 78.子集
- 回溯 给定不包含重复元素的整数数组 返回所有可能的子集
nums = [1,2,3]    
result = [[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]
1. 输入：
    已知条件：nums
    全局变量：path result
    过程变量：startindex
2. 终止条件：
    不论如何都是需要收集子集的
    如果startindex>=len(nums) return
3. 递归逻辑

### 90.子集Ⅱ
- 回溯： 给定一个包含重复元素的整数子集，返回数组所有可能的子集
- 思路：
    - 满足不重复取元素：
        - 先对集合排序 如果nums[i]==nums[i-1] continue
        - 回溯时候i+1

## 排列
### 46.全排列
- 给一个没有重复数字的序列 返回所有可能的全排列
1. 输入：
    已知内容：nums
    全局变量：path result   
    过程变量：used
2. 终止条件：
    len(path)==len(nums)
3. 递归逻辑：
    如果used[i] is true continue
    else
        used[i] = True
        各种回溯
        used[i] = False


### 47.全排列Ⅱ
- 给一个有重复数字的序列 返回所有可能的全排列
- 和全排列1的区别：
    - 对元素进行排序 如果出现连续两个重复的话就continue
1. 输入
    已知条件: nums
    输出变量: result path
    过程变量: used

## 棋盘问题
### 51.N皇后

### 37.解数独

## 其他
### 491.递增子序列（和子集问题很像）
- 例子：
输入: [4,6,7,7]
输出: [[4,6], [4,7], [4,6,7], [4,6,7,7],[6,7],[6,7,7], [7,7], [4,7,7]]
1. 输入
    已知条件：nums
    输出变量：path result
    过程变量：startindex uset表示本层元素是否有重复出现过
2. 终止条件：
    递增序列大于1的时候可以append
3. 递归逻辑：
    利用uset=set()对本层元素进行驱虫
    for i in range(startindex,len(nums)):
        if (path and nums[i] < path[-1]) 不满足递归 or nums[i] in uset:
            continues
        uset.add(nums[i])
        path.append(nums[i])
        self
        path pop


> s1 = set([1, 2, 3, 3])  # 从列表创建，结果：{1, 2, 3}
> s2 = set("hello")       # 从字符串创建，结果：{'h', 'e', 'l', 'o'}
> s3 = set((1, 2, 2, 3))  # 从元组创建，结果：{1, 2, 3}

### 332.重新安排行程
