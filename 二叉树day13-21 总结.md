# 二叉树
递归法：函数的参数和返回值、终止条件、单层递归的逻辑

## 二叉树的遍历方式
### 144. 二叉树的前序遍历
题目: 输入root 返回二叉树的前序遍历
- 递归法
    1. 函数的参数和返回值：输入root 返回数组[]
    2. 终止条件: 当所有节点都被遍历完 root is None return 只需要返回空的内容
    3. 单层递归的逻辑 append(root.val)->traversal(root.left)->traversal(root.right)
    **函数的闭包 如果内层函数没有定义的话就回去外层找对应的数据**
- 迭代法
    审题：目标函数是中左右 所以需要先放入右边孩子 再放入左边孩子 再回退的栈存储方式

### 145. 二叉树的后序遍历
- 递归法
- 迭代法
    审题：目标顺序是左右中 因为没有办法先回退 所以先构造中右左 先让入左边孩子 再放入右边孩子 最后返回res的[::-1]
### 94. 二叉树的中序遍历
- 递归法
- 迭代法
    审题：目标顺序是左中右 需要先放到最左下角 然后判断 如果左边没有元素了 那就可以返回该值并且cur=cur.right

### 102. 二叉树的层序遍历
- 迭代法
    建立一个deque 对于每一行 需要将队列的元素给pop出去 不断的append 结果先是呈现level 后面是呈现整一个result

### 117. 填充每个节点的下一个右侧节点指针二
- BFS万能方法 遍历每一个层 每一层的prev初始值都为None 开始时候让prev为初始的node节点 不断pop节点的时候让prev.next=node

## 二叉树的属性
### 101. 对称二叉树
- 看一下二叉树是不是镜像对称的 外侧等于里侧 需要用到递归: 这里也可以理解为是一种回溯 
- 递归 
    1. 输入 root.left 和 root.right 输出为bool 所以需要第二个def
    2. 终止条件 如果左右不一样 false
    3. 单层递归的逻辑: 
        对比外侧：compare left.left right.right
        对比内侧：compare right.left left.right
        对比外侧内侧是不是都一样
### 104. 二叉树的最大深度
- BFS万能方法 遍历每一个层数 每一层的depth都+1 遍历完全之后可以return depth
- 递归
    1. 输入root 输出int
    2. 终止条件 root is None
    3. 单层递归逻辑：
        计算左边的深度
        计算右边的深度
        深度=max（左边的深度，右边深度）+1

### 111. 二叉树的最小深度
- BFS万能方法 BFS可以遍历每一个层数 每遍历一层就+1 如果出现了存在not left and not right的情况就return depth
- 递归
    1. 输入node 输出int
    2. 终止条件: 空节点返回0
    3. 递归逻辑:
        1. 如果左孩子为空 右孩子不为空
            高度为右孩子高度+1
        2. 如果右孩子为空 左孩子不为空
            高度为左孩子高度+1
        3. 其他情况
        计算左边最小深度
        计算右边最小深度
        深度=min（左边最小深度，右边最小深度）+1
### 222. 完全二叉树的节点个数
- 递归
    1. 输入root 输出 int
    2. 终止条件 if node is None: return 0
    3. 递归逻辑
        计算左子树的个数
        计算右子树的个数
        个数=左子树的个数+右子树的个数+1
### 110. 平衡二叉树
- 递归: 判断每一个节点的左右两个子树高度差的abs<=1
    1. 输入 root 输出 bool
    2. 终止条件 如果为空节点 True
    3. 递归逻辑
        判断左子树的高度 如果左子树不平衡 return -1（代表不平衡）
        判断右子树的高度 如果右子树不平衡 return -1（代表不平衡）
        如果左右子树高度差大于1 不平衡
        否则 返回1+max(左子树+右子树)
### 257. 二叉树的所有路径
- 递归：返回每一个根节点到子节点的路径～带有回溯
    1. 输入 root & path每一条路径 & result结果集
       输出 不需要输出 因为这是回溯题型 已经有结果存入了
    2. 终止条件 找到叶子节点 node.left==node.right==None
    3. 单层递归逻辑
        path.append(cur.val)
        如果到达叶子节点 sPath='->'.join(map(str,path)) 并返回
        如果左边不为空 则找左边的路 回溯到上一个节点放到path中
        如果右边不为空 则找右边的路 回溯到上一个节点放到path中
### 404. 左叶子之和
- 递归：返回每一个左叶子的和
    1. 输入 root 输出 leftsum
    2. 终止条件 
        如果当前节点为空节点   return 0
        如果当前节点为叶子节点 return 0
    3. 单层递归逻辑
        左子树之和：如果遇到左叶子 和+=左叶子的值 否则递归
        右子树之和：递归
        左子树之和=左子树的左叶子之和+右子树的左叶子之和
        
### 513. 找树左下角的值
- BFS 层序遍历万能法
- 递归+回溯：先找到最后一行 再找到最左边的值
    1. 输入 root 输出 最长深度int 不需要返回值 result：最大深度最左节点的数值
    2. 终止条件：
        第一次遇到叶子节点 需要统计最大深度+该叶子的值 第一次遇到叶子节点恰好就是最左边的节点
    3. 单层递归逻辑
        求左子树的值 深度加1 求左子树左下角的值 深度减1
        求右子树的值 深度加1 求右子树左下角的值 深度减1

### 112. 路径总和
- 递归
    1. 输入：root targetsum-root.val先把自己的val给删掉
    2. 输出 bool
    3. base case：
        如果为叶子节点 并且count为0 返回 true 
        如果为叶子节点 但是count部位0 返回false
    4. 递归逻辑：
        如果左节点不为空 递归左子树 需要将count-root.left.val
        如果右节点不为空 递归右子树 需要将count-root.right.val



## 二叉树的修改与构造
### 226. 翻转二叉树
- 思路：把每一个节点的左右孩子都翻转 就可以达到整体反转的效果 中序遍历会把左右孩子反转两次 只能用前序和后续遍历
- 递归法：
- 1. 递归函数的参数和返回值: 传入root节点 返回root节点
- 2. 终止条件: 节点为空的时候
- 3. 单层递归的逻辑: 交换左右孩子的节点 再反转左边 再反转右边(这里就用到了递归～)
### 106. 从中序与后序遍历序列构造二叉树
- 递归法： 中序遍历 左中右 后序遍历 左右中 
- 1. 输入数列 输出root
- 2. 终止条件 数列结束了
- 3. 单层递归的逻辑
    1. 如果节点为0 那么直接返回null
    2. 找到中间节点 后序遍历的最后一个节点就是中间节点
    3. 找到中序遍历的左树和右树 后序遍历的左树和右树
    4. 遍历
### 654. 最大二叉树
- 递归法：
    1. 找到最大的元素 变为根
    2. 左边的是左边的 构造出来
### 617. 合并二叉树
- 递归法：每一个节点想家
    1. 输入序列: 两个root  输出序列：1个root
    2. 终止条件: 如果root1为空 或者root2为空 返回对面的
    3. 单层递归逻辑：例如前序遍历
        root1.val
        root1.left和right用递归

## 求二叉搜索树的属性
### 700. 二叉搜索树中的搜索
- 递归法：
    1. 输入：root int 输出：该值所在的节点
    2. 确定终止条件： 如果找到了 返回root 如果root为空 返回root
    3. 单层递归的逻辑：
        如果值小了 往左边找
        如果值打了 往右边找

### 98. 验证二叉搜索树
- 递归法：还是直接append 然后看数列是不是往上增加
    1. 输入root 输出 bool
    2. 确定终止条件： 
        如果root为空 返回True
            如果左边存在 if root.val < root.left.val: false
            如果右边存在 if root.val > root.right.val: false
    3. 单层递归的逻辑:
        看左子树
        看右子树
        
### 530. 二叉搜索树的最小绝对差
- 计算树中任意两节点的差的绝对值的最小值
- 思路：写一下结果 
### 501. 二叉搜索树中的众数
- 找一下树中的众数 其实也是直接写一个数组 然后返回出现次数最多的
### 538. 把二叉搜索树转换为累加树
- 递归：题目理解 原来有一个数 后面要通过右中左的方式返回累加的一个结果
    1. 输入 输入的为cur和root
    2. 输出 返回root
    3. 基本条件 如果root is None 返回
    4. 递归规律
        先递归右边
        cur=cur.val+pre
        pre=cur.val
        在递归左边


## 二叉树公共祖先问题
### 236. 二叉树的最近公共祖先
- 递归+回溯：
    1. 输入 root 输出 节点node
    2. 终止条件：如果root is p或者q或者none 说明root为空或者是最近祖先 所以直接返回root
    3. 单层递归的逻辑：
        递归左边看看有没有结果 递归右边看看有没有结果
        左不空  右不空 说明root是结果 返回root
        左空    右不空 说明结果在右边 返回right
        左不空  右空   说明结果在左边 返回left
        如果都没有找到 说明没有最近祖先 返回None
### 235. 二叉搜索树的最近公共祖先
- 递归+回溯:
    1. 输入root p q 输出 节点cur
    2. 终止条件: 如果cur is None return cur
    3. 单层递归的逻辑：
        如果cur的值比pq的值都要小 那么节点一定要在右边 right递归 并且如果not None就返回right
        如果cur的值比pq的值都要大 那么节点一定要在左边 left 递归 并且如果not None就返回left
        如果不满足两者的情况 那么就return cur

## 二叉搜索树的修改与构造
### 701. 二叉搜索树中的插入操作
- 递归
    1. 输入root val 返回root
    2. 终止条件 if noot is None: 插入新的节点 并且返回node
    3. 如果值大的话 往左边插入 
### 450. 删除二叉搜索树中的节点
- 递归
    1. 输入 root key(删除的值)
    2. 输出 root
    3. 终止条件 如果root是none return root
    4. 递归逻辑
        1）如果为叶子节点 返回None
        2）如果左节点为空 返回右节点
        3）如果右节点为空 返回左节点
        4）如果左右节点不为空 将左节点放在右节点最左下角的元素上 并返回右节点
        如果当前节点的值 < key 那么遍历右边
        如果当前节点的值 > key 那么遍历左边
### 669. 修剪二叉搜索树
- 递归
    1. 输入：root L R L代表最低值 R代表高值
    2. 输出：root
    3. 基本情况 如果节点为none 返回none
    4. 递归逻辑：
        如果节点的值比low小 直接返回该节点的右子树
        如果节点的值比high大 直接返回该节点的左子树
### 108. 将有序数组转换为二叉搜索树
- 递归：
    1. 输入nums left代表数组的左边元素 初始值为0 right 代表数组的右边元素 初始值为len(nums)-1
    2. 输出 root
    3. 基本情况：if left>right return None
    4. 递归要求：
        root=treenode(mid)
        root.left 范围是left,mid-1
        root.right 范围是mid+1,right